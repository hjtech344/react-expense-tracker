# Redux avec react 

1. C'est quoi redux ?
Redux est une biblioth√®que de gestion d‚Äô√©tat qui fournit un moyen pr√©visible de stocker et de mettre √† jour l‚Äô√©tat global 
de l‚Äôapplication.
En utilisant Redux, on va stocker toutes les donn√©es dont on a besoin dans un seul ¬´ store ¬ª, qui peut √™tre partag√© entre
tous les composants de l‚Äôapplication.

2. Quel sont les aventages de redux ?
Les grands avantages de Redux sont les suivantes :

S√©paration des concepts :
Toute la logique de gestion de state √©tant externalis√©e, on rend nos composants ‚Äústateless‚Äù. Ainsi, ils n‚Äôont plus qu‚Äôun seul
r√¥le : afficher les portions de l‚ÄôUI.

√âtat immuable :
Le store Redux est immuable, ce qui signifie que l‚Äô√©tat ne peut pas √™tre modifi√© directement. On va passer par des ‚Äúactions‚Äù,
qui sont des objets d√©crivant ce qui doit √™tre modifi√©. Cette approche garantit que l‚Äô√©tat de l‚Äôapplication reste coh√©rent 
et facilite la d√©tection des erreurs.

Facilite la gestion des mises √† jour d‚Äô√©tat :
Redux utilise un m√©canisme appel√© ¬´ reducers ¬ª pour g√©rer les mises √† jour de l‚Äô√©tat. Ce sont des fonctions qui vont produire
un nouveau ‚Äústate‚Äù. Cette approche facilite la gestion des mises √† jour d‚Äô√©tat ainsi que la gestion des interactions 
complexes entre les diff√©rents composants de l‚Äôapplication.

Facilite le d√©bogage :
Redux facilite le d√©bogage de l‚Äôapplication en stockant toutes les actions qui ont √©t√© dispatch√©es dans un journal. Cela vous
permet de voir exactement ce qui s‚Äôest pass√© dans l‚Äôapplication √† un moment donn√©, ainsi que de comprendre comment l‚Äô√©tat a 
chang√©, et de revenir en arri√®re pour voir ce qui s‚Äôest pass√© lors d‚Äôune interaction sp√©cifique.

Facilit√© de partage de l‚Äô√©tat :
En stockant l‚Äô√©tat global de l‚Äôapplication dans le store Redux, il devient facile de partager l‚Äô√©tat entre diff√©rents 
composants de l‚Äôapplication. Cela peut √™tre utile pour les applications qui n√©cessitent une coordination complexe entre 
diff√©rents composants.

Gestion d‚Äô√©tat centralis√©e :
On stocke l‚Äô√©tat global de l‚Äôapplication dans un seul endroit, appel√© ‚Äúle store‚Äù, ce qui nous permet de maintenir une vue
d‚Äôensemble de l‚Äô√©tat de l‚Äôapplication. C‚Äôest plus simple √† maintenir, mais aussi √† faire √©voluer, et le ‚Äústate‚Äù est √©galement
plus facilement accessible √† tous les composants.


Remarque : Il ne faut pas centraliser tout le state en dehors des composants. Il faut centraliser ce qui concerne la 
configuration de l‚Äôapplication, ou tout √©tat global partag√© entre les composants.

üë®‚Äçüè´ Exemple :
Un √©tat de theme (dark/light ou compact/large) doit aller dans Redux, ce qui permettra de le r√©cup√©rer dans les diff√©rents
composants. Le token de l‚Äôutilisateur connect√© peut, lui aussi, aller dans Redux. Par contre, un listing d‚Äôune ressource 
(liste d‚Äôutilisateurs, d‚Äôarticle de blog‚Ä¶) ne doit pas y aller, car l‚Äô√©tat d‚Äôun composant ne doit pas se retrouver dans Redux.


# le fichier jsconfig.json : le fichier jsconfig est une configuration qui va dire a react que notre dossier principale
ou baseUrl se trouve dans le dossier .src/  et qu'on est en react, cela va nous permettre de faire nos import sans mettre
des chemin relatifs. Ex : './App.js' maitenant on doit specifier seulement le nom du dossier puis le nom du fichier.

Pour le Tp redux on va besoin de deux librairies qui sont :
@reduxjs/toolkit@1.9.0  et react-redux@8.0.5
pour lancer l'installation il suffit de mettre npm install devant le nom de ces librairies.

Explication :
@reduxjs/toolkit c'est le coeur de reduxjs, toolkit c'est une espece de surcouche autour de redux qui permet de rendre 
redux plus facile a utiliser et qui donne acces a plein de nouvelle fonctionalit√©es.

react-redux c'est la librairie specifique qui permet de communiquer avec redux quand on est avec react.

# Comment configurer redux avec react ?
Pour configurer redux avec react il suffit d'aller dans le dossier /src puis creer un nouveau dossier appel√© store
puis dans store on va creer un fichier appel√© index.js c'est dans ce fichier qu'on va faire la configuration de redux.

configuration de redux : 
1. on va importer configureStore depuis la librairie @reduxjs/toolkit
2. on va declarer une costante appel√© store on va lui affecter une valeur, cette valeur est la fonction configureStore 
qu'on vient d'import√© tout a l'heure. cette fonction configureStore va prendre param un objet. Dans cette objet on va
avoir une cle appel√© reducer qui a comme valeur pour l'instant un objet vide. puis il faut exporter cette constante
pour que nous puissons acces avec. ceci est la configuration minimale pour que redux fonctionne dans notre app react.

pour que cela fonctionne il faut aller dans la racine de notre app qui est index.js , Dans index.js on va importer
un composant appel√© Provider qui vient de la librairie react-redux. Apres l'importation on va enrober ou entourer
notre composant App avec ce composant Provider. ce composant provider lui meme a besoin d'un props(c'est requis) ce props
est appel√© store , puis que nous avons configurer une constante store au paravant donc il suffit d'importer cette constante
puis de le passer a la props store du composant Provider.

pour bien utiliser redux et pour le debogage il suffit d'installer une extension dans notre navigateur qui s'appelle
redux dev tools. puis on peut profiter de redux.


# Concept important de redux depuis toolkit : slice et etat initial
sclice : les tranches
Dans redux on va avoir toutes nos donn√©es sous formes de json : key et value, quand on va creer des section a chaque fois
dans le json , on cree une slice ou une tranche de donn√©. par exemple on va creer une slice qui va permet de gerer les
depences de l'application. pour cela on va dans le store/ puis on va creer une section appel√© expensive/ dans ce dossier
on va creer un fichier appel√© expensive-slice.js . c'est dans ce fichier qu'on va creer nos slice ou tranche de donne

1. on doit importer une fonction appel√© createSlice a partir de la librairie @reduxjs/toolkit
Ensuite une slice ou tranche de donn√© lorsqu'on va le creer c'est un objet mais c'est pas un objet qui contient seulement
des donn√©es , puis qu'en arri√®re il nous permettent de modifier les donn√©es de notre sclice et faire plein d'autre choses.

2. on va declarer une constante on va lui affecter la fonction createSlice qu'on vient d'importer puis on va lui passer une
cle appel√© name qui prend comme valeur en generale le nom du slice c'est a dire le nom de la constante

3. etat initial : on va lui passer une deuxi√®me cle qui aura comme valeur les donn√©es qu'on veut avoir lors de
l'initialisation dans notre cas ce sera expenseList qui sera un tableau vide []. 

4. on doit faire la reference de cette sclice, pour cela on doit aller dans le fichier index de notre store puis
on va creer une cle en maj dans notre cas on va l'appeller EXPENSE qui va prendre comme valeur les donn√©es rafrechis 
du slice en question pour cela nous allons importer notre expenseSlice puis on va utiliser .reducer pour ecouter ou
verifier si quelque chose a chang√© dans notre tranche de donn√© et de le mettre a jour dans la cle.


# Ecrire dans le store avec les actions et useDispatch() :

comment creer une action ?
une action c'est une fonction qu'on va ecrire dans notre slice ou tranche de donn√© qui nous permettons de modifier
notre sclice quand on va l'appeler.

EXO-1 : on va remplacer Expence input par un formulaire qui nous permettons de taper un nom et prix et mettre un boutton
de validation. Le but c'est quand on va cliquer sur le boutton de validation pour qu'on ajoute ces infos dans le tableau
expenseList de notre store.

1.pour cela on va aller dans notre composant App puis on va remplacer le texte expense input par le composant expenseInput

2. On va preparer une fonction d'evenement pour recuperer les donn√©es du formulaire lorsqu'on appuie sur le boutton add
et ensuite les envoy√© a l'action qu'on va creer.
pour cela on va creer une fonction appel√© handleSubmit, on va desactiver le comportement par defaut du formulaire.
pour recuperer les donn√©es du formulaire on faire une nouvelle initialisation de : new FormData() qui va prendre les donn√©es
que l'utilisateur a saisi. new FormData(currentTarget) puis sur la variable de l'initialisation on va recuperer les 
donn√©es du champs du formulaire grace a la methode get('name du champs input') apr√®s on doit envoy√© notre fonction au 
formulaire grace a la fonction d'evenement onSubmit(handleSubmit)

3.creation des actions : comme nous dissons deja pour creer des actions on va aller dans notre slice ou tranche de donn√©
Dans le slice par exemple expenseSlice nous allons creer des action grace a la cle reducers, les actions sont ni plus ni 
moins que des fonctions la cle reducers va prendre comme valeur un objet c'est dans cette objet qu'on va mettre le nom
de l'action qu'on veut creer comme cle et il aura comme valeur la fonction () => { } a l'interieure de la fonction on peut
acceder a tous les donn√©es de notre slice grace au param de l'action on peut lui donner un nom selon nos gout dans mon cas
je vais l'appeler currentSlice puis a l'interieure de la fonction on peut faire nos donn√©s d'initialisation dans mon cas
expenseList puis on peut push mettre des donn√©es dans le slice.Ex : currentSlice.expenseList.push({nouvelle donn√©})

4. pour pouvoir utiliser l'action il faudra l'exporter , pour l'exporter il a deux fa√ßon de faire cela :
a- on creer une constante puis on l'affecte le slice.actions.nom-de-la-fonction-de-l'action
Ex : const addExpense = expenseSlice.actions.addExpense
puis apr√®s on fait export { addExpense }

Plus tard quand on aura plein d'action il faudra faire la meme etape ce sera trop repetitif donc, javascript nous donne
la posibilite de faire la destructuration des variable c'est ce qu'on va faire dans la deuxieme methode.

b- La deuxieme methode consiste a destructurer nos variable ou constante comme ceci
Ex : const { addExpense, autre_action }  = slice.actions;
puis apr√®s on fait export { addExpense, autre_action }

# comment appeller une action :
Remarque : redux fonctionne comme un systeme d'event et listener
En effet les actions sont des evenements qu'on va envoyer a nos slice qui comporte comme des listener
quand un slice a une action et il va ecouter quand l'action va etre appel√© et il va executer cette action.

pour cela pour emettre un evenement on doit fait appelle a un hook de react-redux qui est appel√© useDispatch()
useDispatch() : son role est d'emettre des evenements
Dans notre cas on va utiliser useDispatch pour emettre l'evenement addExpense depuis notre composant expenseInput comme
ceci : 
a- on va stocker useDispatch dans une variable dispatch en dehors de notre fonction d'evenement
b- on va dire a dispatch d'emettre l'evenement de la fonction addExpense() Ex : dispatch(addExpense())

# comment recuperer les donn√©es qui provient du formulaire dans les actions :
pour recuperer les donn√©es du formulaire dans les actions il faut preceder ainsi :
a- il suffit de passer nos variable lors de l'emission de l'evenement
b- pour avoir acces a nos variables qu'on a emis lors de l'envoie de l'evenement on doit passer le mot action comme 
deuxi√®me paramettre au niveau de notre evenement dans le sclice.

Les action qui est comme deuxi√®me argument envoie toujours un objet qui contient deux elements :
1. type : nom du slice / nom de l'action : c'est comme un identifiant de l'action
2. payload : { les donn√©es qu'on avait envoy√© lors de l'emission de l'evenement }

Remarque : ExpenseInput c'est un composant qui est devenue connect√© au store puisque il utilise useDispatch pour ecrire
dans le store. Maintenant il n'est plus un composant g√©n√©ric c'est a dire ce n'est plus un composant que quelqu'un peut
peut utiliser depuis sons app , c'est vraiment lier a notre logique. Dans ce cas quand on contient des composants qui ont 
un comportement comme √ßa on cree un dossier appel√© container dans le dossier components puis on les deplacent dans ce
dossier. c'est pour indiquer a quelqu'un ou un autre dev que les composants qui se trouvent dans ce dossier ce sont des 
composant connect√©es, que ce sont pas des composants qu'on peut utiliser n'importe o√π dans le projet.

Nb : Un composant est un container lorsqu'il est connect√© au store d√®s qu'il lit ou il ecrit depuis le store.


# Comment lire dans le store avec useSelector() :

EXO-2 : 
on va recuperer les donn√©es du slice ou tranche de donn√© ensuite l'afficher a la place du text expense history

pour cela on va dans le composant App on va importer le composant List, puis remplacer le par le text expense history
ce composant va avoir un props items qui sera un tableau [] qui va contenir les donn√©es du slice.

ce composant va retourn√© un autre composant ListItem qui sera une liste qui va afficher un nom et un prix.
ce composant ListItem va recevoir un props item qui va erite de items du composant List.

pour lire des donn√©es dans des sclice dans le store il faut suivre les etapes suivantes :
1. importe un hook de react-redux appel√© useSelector()
2. on stocke useSelector dans une constante ou variable
3. useSelector() est une fonction qui nous permet d'avoir une fonction callback
qui nous permet d'acceder au store , puis dans cette fonction on va decider qu'est ce qu'on veut retourn√© du store
4. ensuite il suffit de mettre la cle du sclice qui est dans le store qu'on veut lire . le nom de initialState qui est dans
le slice ou tranche de donn√© on peut consulter redux dev tools pour voir l'achitecture des donn√©es qu'on veut lire.


# Spread operator optionel :
Les spread operator c'est un outil de ES6 qu'on utilise sur les tableau et les objets pour faire des modification plus 
radipedement avec moins de ligne de code.

spread operator avec les tableaux : Par exemple si on a un tableau fruitJaune qui contient : banane et orange comme element , et un autre tableau 
fruitRouge qui contient elle aussi cerise et fraise comme element et un autre tableau fruitVert qui contient avocat comme
element. si on donne a une var ou const la valeur de ces tableau on va recevoir comme resultat. un tableau qui contient 
trois tableaux a l'interieure : Ex : const fruits = [[banane, orange], [cerise, fraise], [avocat] ]

pour recevoir seulement les elements des tableaux on doit faire une destructuration ou concatenation des tableaux avec ceci :
il suffit de mettre un spread operator ou trois poins l'une apr√®s l'autre devant le nom du tableau. 
Ex : fruits = [...fruitJaune, ...fruitRouge, ...fruitVert]

Cela veut dire qu'au tableaux de prendre seulement les elements qu'ils contient et de nous l'envoy√©. comme ceci :
Ex : fruits = [banane, orange, cerise, fraise, avocat] 

spread operator avec les objets :  Par exemple si on a un objet fruitJaune qui contient : comme cle fruit1 et banane  
comme valeur, puis fruit2 comme cle et orange comme valeur et on a un autre objet fruitRouge qui contient : comme cle fruit3 
et valeur fraise, puis fruit4 comme cle et cerise comme valeur et on a un troisi√®me objet fruitVert qui contient comme cle 
fruit5 et comme valeur avocat. si on donne a une var ou const la valeur de ces objets on va recevoir comme resultat. un objet 
qui contient trois objets a l'interieure : Ex : const fruits = {{banane, orange}, {cerise, fraise}, {avocat} }

pour recevoir seulement les elements des objets on doit faire une destructuration ou concatenation des objets avec ceci :
il suffit de mettre un spread operator ou trois poins l'une apr√®s l'autre devant le nom de l'objet. 
Ex : fruits = {...fruitJaune, ...fruitRouge, ...fruitVert} 

modification dans un objet existant avec spread operator :
pour faire des modification sur un objet existant il faut suivre les etapes suivantes :

1. faire un copie de l'objet ou du tableau avec la syntaxe de spread operator ...
2. pour modifier la valeur il suffit de specifier la cle existante de l'element de l'objet et une valeur

Ex : const copieFruits = {...fruits, fruitVert : quen√™pe} puis la valeur quen√™pe va remplacer avocat dans la cle fruitVert

# EXO-3 : On va creer le composant IncomeInput (revenueInput) pour entrer notre revenue initial, cela va permettre lorsqu'on
entre un revenu ca va directement dans le store. pour que plus tard dans la section qui affiche le total et l'argent restant
pour qu'on puisse faire un calcul entre l'argent qu'on avait initialement et la somme de nos depenses.

Les etapes qu'on va faire :
1. on va dans le composant App on va remplacer le composant IncomeInput par le text income input, ce composant 
contient un props

2. faire une fonction onChange qui va recuperer la valeur qu'on saisi dans le composant IncomeInput
3. on va mettre un nouveau section dans le sclice avec une valeur par defaut qui sera de type entier ou float,
4. on va lire la valeur du nouveau section dans le store dans l'input du composant IncomeInput avec le useSelector
l'input va recevoir cette valeur dans son attribut defaultValue

5. on va faire changer cette valeur dans le store quand on saisi un nouveau valeur , pour cela on doit creer une nouvelle
action pour envoyer au store la valeur qu'on saisi dans l'input.
6. on doit changer le type de l'icome qu'on a recu du formulaire en float pour cela on doit convertir le str en 
Number.parseFloat(nom de la variable str)
7. on va changer le type de price dans la section expenseList, pour cela on doit faire un spread sur l'objet puis faire
la convertion sur la valeur qu'on veut convertir
8. puisque ce composant devient un composant connect√© au store on doit le deplacer dans le dossier components/container


# reduce [optionel] :
reduce c'est une fonction qui resemble a map qui va s'appliquer sur les tableaux et il retourne comme resultat un
seul element. 

par exemple : on a un tableau qui contient : [1,2,10] , si on veut a la sortir qu'on retrouve avec la somme de ce tableau
on doit appliquer la fonction reduce.

comment cette fonction marche ?
1. on doit faire .reduce sur le tableau en question 
2. cette fonction reduce((acumulator, currentItem) => {}, 0) a acces avec un acumulator c'est l'indice de depart
de l'itteration et il en acces a l'element courant qui sont les element du tableau.
3. en deuxi√®me paramettre on doit passer la valeur qu'on veut pour l'acumulator (la valeur initial)
4. on peut faire l'operation d'addition pour trouver la somme des elements du tableau : return accumulator + currentItem
5. si on veut on peut deplacer la fonction en dehors de reduce et l'envoyer en premier paramettre de reduce et la valeur
initial en deuxi√®me paramettre.


#EXO-4 : Dans cette exercice on va remplacer le composant ExpenseTotal dans la section expense total dans le composant
App puis on afficher le prix total de nos depenses c'est a dire la somme de nos depenses, en second lieu on va faire
la difference entre l'argent initial qu'on avait et la somme de nos depences c'est a dire on va faire la soustraction entre
l'argent initial : income et la somme d'argent depens√© ExpenceList.

Les etapes pour realiser cette exercice :
1. on va remplacer le composant ExpenseTotal dans App
2. on va recuperer la somme des argents depens√© dans le store avec les useSelector()
3. on va faire la somme de tous les argents depens√© et l'afficher dans le composant ExpenseInput
4. on va recuperer la somme d'argent initial
5. on va faire la soustraction de l'argent initial et la somme d'argent depens√©

# Persister le store :
Pourquoi utiliser Redux Persist ?
Redux Persist est un outil de gestion d'√©tat qui permet √† l'√©tat d'un magasin Redux de persister entre les sessions
de navigateur et d'application, am√©liorant ainsi l'exp√©rience utilisateur en pr√©chargeant le magasin avec des donn√©es 
persistantes. Il offre √©galement une protection contre les pannes inattendues et les probl√®mes de r√©seau, emp√™chant la
perte de donn√©es et offrant une exp√©rience utilisateur plus fiable.

Redux Persist propose diff√©rentes configurations, notamment des strat√©gies de mise en cache personnalis√©es, la 
possibilit√© de choisir les parties de l'√©tat √† conserver et √† exclure, ainsi que le m√©canisme de stockage √† utiliser. 
Il est √©galement dot√© de fonctionnalit√©s int√©gr√©es telles que les migrations, les transformations et les fusions 
personnalis√©es.

comment persister le store ?

La persistance d'un store permet de gader les donn√©es en memoire lorsqu'on rafrechis une page. on peut dire aussi
c'est l'action d'enregistrer toutes les donn√©es du store dans le systeme de cache du navigateur pour qu'on puisse
conserver ces donn√©es lorsque la page est rafrechis.

pour persister le store il faut installer une librairie de redux nomm√© redux-persist avec la commande svt :
npm i reduxt-persist. Apr√®s l'installation du biblioth√®que on doit importer 4 fonctions pour la configuration de la
persistance du store.

voici les etapes a suivre pour configurer la persistance du store :
1.etape d'importation des fonctions dans diff√©rents librairie
on doit importer :
 combineReducers depuis @reduxjs/toolkit
 storage depuis redux-persist/lib/storage
 persistStore et persistReducer depuis redux-persist

Qu'est ce que combineReducers ?
combineReducers : c'est une fonction qui nous permettent de combiner nos reducers

Comment les reducers fonctionnent ?
Leur fonctions c'est d'appeller chaque r√©ducteur de tranche √† chaque fois qu'une action est envoy√©e et rassemble leurs 
r√©sultats dans un seul objet d'√©tat. Cela permet de diviser la logique du r√©ducteur en fonctions distinctes, 
chacune g√©rant sa propre tranche d'√©tat de mani√®re ind√©pendante.

2. on va declarer une fonction qui va contenir l'ensemble de nos reducers combin√© par exemple dans mon cas je vais creer
une const rootReducers en effet c'est la racine de nos reducers. puis on va envoyer nos reducers dans la fonction 
combineReducers({allreducers})

3. pour persister nos tranches de donn√©es on va creer une constante appel√© persistedReducers on l'affectera a la fonction
persistReducer({}) puis en second lieu on va envoyer la variable qui contient nos reducers combin√© dans mon cas c'est
rootReducers.

persistReducer(param1, {rootReducers}) : va prendre en premiere paramettre une petite configuration pour dire comment on 
veut persister nos reducers.

4. on doit creer une constante pour configurer la persistance des reducers : par exemple dans mon cas on va creer une const
appel√© persistConfig qui sera un objet , il avoir un premier element qui sera un cle (key) : c'est une identifiant qui
va representer nos donn√©es dans le cache en general on lui donne comme valeur root, un deuxi√®me element on doit specifier 
la version, ensuite il faut presicer ce qu'on va utiliser comme systeme pour persister nos donn√©es, dans mon cas c'est 
storage.

5. il faut envoyer les donn√©es persit√© au configuration du store c'est a dire dans la fonction de configureStore(), Dans
mon cas les donn√©es persist√© qu'on va envoyer c'est persistedReducers dans la cle reducer.

6. pour pouvoir acceder a nos donn√©es persist√©es du store dans nos composants on doit creer une petite variable appel√©
persistor puis on va affecter a la variable persistor la fonction persistStore() qui va recevoir notre store.
c'est grace a cette variable qu'on pouvoir acceder au donn√©es persist√© du store depuis l'exterieure.puis il faut l'exporter

7. Dans la racine de notre app c'est a dire l'index on doit importer :
PersistGate : qui est un composant qui va recevoir les donn√©es persistant de notre store
PersistGate se trouve dans redux-persist/integration/react

8. on doit enrober ou entourer le composant App avec le composant PersistGate qui va recevoir comme props persistor
qui sont les donn√©es persister de notre store.

9. Apr√® cette configuration tous va fonctionner, mais on va trouver une petite erreur ce n'est pas grave pour corriger cette
erreur on va sur la documentation dans la section use with redux-persist . Qui nous expliquent si on utilise redux-persist
il y a des actions de type dispatch qu'on doit ignorer par exemple voici une liste :
FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER ensuite il va faloir dire a redux dans le configureStore d'aller ignorer
ces types d'actions.

middleware : (getDefaultMiddleware) => {
    return getDefaultMiddleware({
      serializableCheck : {
        ignoredActions : [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER ]
      }
    });
}
apr√®s tout devrait fonctionner correctement.

10. par defaut toutes les tranches de donn√©s ou slice sont persister , mais on a la possibilit√© de specifier quel tranche
de donn√© qu'on veut persister. pour cela on doit aller dans notre variable de configuration qui etait persistConfig
pour aller dire qu'on va envoyer une whiteList ou blackList. si on met un whiteList = [] il va arreter de persister toutes
les donn√©es sauf ceux qu'on mettre dans le whiteList. le nom qu'on va mettre c'est le nom de la cl√© de la tranche de donn√©.
Dans le cas on utilise un blackList = [] on dit a redux de persister toutes les donn√©es sauf ceux qui sont dans la blackList


# Les middleware avec redux :
Le middleware Redux fournit un point d'extension tiers entre l'envoi d'une action et le moment 
o√π elle atteint le r√©ducteur .
Avec les middleware on peut se mettre en ecoute sur les actions. 
puisque les middleware sont en dessous des actions on peut ecouter n'importe quel action
par exemple si on ajoute une depense on peut ecouter cette action et afficher cette depense dans la console ou 
l'enregistrer dans une base de donn√© pour faire de l'analyse etc...

#EXO-5 : on va creer un logger pour toutes nos actions dans l'application et on va afficher ces actions dans la console

Les etapes a suivre pour creer le middleware logger :
1. Dans le dossier store/ on va creer un dossier appel√© middleware/ ensuite on va creer un fichier appel√©
logger-middleware.js 
2. Dans le fichier logger-middleware.js on va ecouter les actions de notre app 
3. on doit importer une fonction appel√© createListenerMiddleware depuis @reduxjs/toolkit
4. on va creer une constante appel√© loggerMiddleWare on lui affecte la fonction createListenerMiddleware

5. pour que cette middleware fonctionne il faut dire a redux de l'utiliser pour cela on va dans le fichier index.js de notre
store dans la section middleware sur getDefaultMiddleware on fait ceci :
getDefaultMiddleware().prepend(nomDuMiddleware.middleware)

6. on va dire a notre middleware de se mettre en ecoute : nomDuMiddleware.startListening({}) dans ce listener on va envoyer
deux choses :
a- Quels action qu'on veut ecouter
b- Qu'est ce qu'on veut faire a chaque fois que l'une de ces actions qu'on ecoute est appeller

pour presicer quel action qu'on veut ecouter on doit utiliser la fonction predicate : () => {}
pour preciser qu'est ce qu'on veut faire lorsque cette action est appeller on doit utiliser la fonction 
effect : async () => { } qui est une fonction asynchronne. chacune de ces fonction recoit un argument cacher qui est action
A chaque fois une action va etre appeler il va passer dans ces deux fonctions , dans la fonction predicate on va filtrer les
actions pour dire que si on veut le garder ou pas pour cela on utilise un boolean.

7- on peut afficher l'etat du store juste apr√®s que l'action soient passer, pour cela on doit passer comme deuxi√®me
argument dans la fonction effect : async (action, listenerAPI) sur ce listenerAPI on peut utiliser une fonction getState()
pour recuperer toute le store. √ßa va afficher l'ensemble du store

8- pour ecouter sur une action specifique ou precis on doit utiliser le paramettre action de la fonction predicate
ensuite on a accer au type et au payload, on peut dire on va ecouter si tel action est de type nomDuSlice/nomDeL'action
Donc ca va envoyer a la fonction effect seulement les action qu'on a specifier.

9- pour ecrire moins de code et capturer tous qu'on veut il y a une petite fonction dans reduxjs/toolkit qu'on peut
utiliser c'est isAnyOf. pour utiliser ces fonctions on doit mettre matcher a la place de predicate et utiliser isAnyOf()
comme valeur. ensuite dans la fonction isAnyOf(action1, action2) on peut specifier quel action on va gader ou ecouter.
on doit importer ces actions depuis notre tranche de donn√© ou slice.

10- pour dispatcher un element depuis le middleware on doit proceder ainsi :
par exemple dans notre slice on peut avoir une section qui contient le nombre de fois que les actions de notre 
app est appeler pour cela on va creer une nomm√© countActionPerformed : 0 par defaut on a 0 action appeler
et a chaque fois qu'on va appeler une action on va augmenter countActionPerformed de +1, pour cela on doit creer une 
action appel√© incrementActionCountPerformed qui va faire currentSlice.countActionPerformed++ puis on va l'exporter

11- on va retourn√© vers notre logger pour aller dispatcher l'action incrementActionCountPerformed quand une action a 
√©t√© ecout√© par la fonction matcher. pour faire cela il suffit d'utiliser la fonction dispatch sur le deuxi√®me paramettre
de la fonction effect qui est listenerAPI pour emettre l'action ou l'evenement incrementActionCountPerformed()































































